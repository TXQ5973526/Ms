分支指令
===================

这些指令使执行执行跳转至通常由标记指定的目标位置（请参阅 ``label`` 汇编指令）。条件分支及 ``it`` 和 ``ite`` 指令测试应用程序
状态寄存器（APSR）、N（负）、Z（零）、C（进位）和V（溢出）标志以确定是否应执行分支。

大多数公开的汇编程序指令（包括移动操作）会设置标志，但有明确的比对指令来允许测试值。

有关条件标志含义的更多细节，请参见描述比对函数的章节。

文件规范
--------------------

符号： ``Rm`` 表示ARM寄存器R0-R15。 ``LABEL`` 表示由 ``label()`` 汇编指令定义的标记。 ``<condition>`` 表示下列条件说明符之一:

* eq 相等（结果为0）
* ne 不相等
* cs 设置进位
* cc 清除进位
* mi 负
* pl 正
* vs 设置溢出
* vc 清除溢出
* hi > （无符号比对）
* ls <= （无符号比对）
* ge >= （有符号比对）
* lt < （有符号比对）
* gt > （有符号比对）
* le <= （有符号比对）

转移标记
---------------

* b(LABEL) 无条件转移
* beq(LABEL) 若相等则转移
* bne(LABEL) 若不相等则转移
* bge(LABEL) 若大于等于则转移
* bgt(LABEL) 若大于则转移
* blt(LABEL) 若小于则转移（<）（有符号）
* ble(LABEL) 若小于等于则转移（<=）（有符号）
* bcs(LABEL) 若设置进位标志则转移
* bcc(LABEL) 若清除进位标志则转移
* bmi(LABEL) 若为负则转移
* bpl(LABEL) 若为正则转移
* bvs(LABEL) 若设置溢出标志则转移
* bvc(LABEL) 若清除溢出标志则转移
* bhi(LABEL) 若高于则转移（无符号）
* bls(LABEL) 若低于或相等则转移（无符号）

长分支
-------------

以上列出的转移指令生成的代码使用固定位宽来指定与PC相关的转移目标。 因此，在转移指令远离其目标的长程序中，汇编程序将产生"转移不在范围内"的错误。这可以通过诸如"宽"这样的变量来克服

* beq\_w(LABEL) 若相等则长分支

宽分支使用4字节来编码指令（标准转移指令为2字节）。

子程序（函数）
-----------------------

输入子程序时，处理器将返回地址存储在寄存器r14中，也称为链接寄存器（lr）。通过从链接寄存器更新程序计数器（r15或pc），在执行子程序调用后返回该指令，此过程由以下指令处理。

* bl(LABEL)

在 ``LABEL`` 将返回地址储存到链接寄存器(r14)后，将执行传输到指令。

* bx(Rm) 转移到由Rm指定的地址。

通常，发送 ``bx(lr)`` 以从子程序中返回。对于嵌套子程序，在执行内部子程序调用前，须保存外部范围的链接寄存器（通常在堆栈上）。

.. currentmodule:: machine
.. _machine.Signal:

Signal类 -- 控制和感应外部I/O设备
======================================================

信号类是引脚类的简单延伸。信号类增加了对引脚功能的逻辑反转支持。虽然这看起来只是简单的补充，
但这正是支持通过不同板进行移植的多种简单数字设备所需要的，这也是MicroPython的主要目标之一。
无论不同用户是否有低电平有效或高电平有效的LED，常开或常闭的继电器—您都可开发一个单独的、外观漂亮的应用程序，
此程序可与每个应用程序一起运行，并在应用程序的配置文件的几行中捕捉硬件配置的差异。

以下为信号vs引脚的使用指南:

* 使用信号: 若您想要控制一个类似LED、多段指示器、继电器、蜂鸣器等的简单开/关（包括软件PWM！）设备，
  或读取类似常开或常闭按钮、拉高或拉低、磁簧开关、水分/火焰检测器等简单的二进制传感器。总之，
  若您有一个需要GPIO访问的真实的物理设备/传感器，您可能需要使用信号。

* 使用引脚: 若您实现一个更高水平的协议或总线以与更多复杂设备通信时。

引脚与信号的差异来自上述使用情况和MicroPython架构：引脚可实现最低开销，这对位拆裂协议十分重要。
但是信号在引脚基础上更具灵活性，尽管这种灵活性是以低开销为代价的（远远小于您在Python中手动实现高电平有效vs低电平有效设备差异！）
引脚是一个需要每种支持板实现的低电平对象，而新信号是一个高电平对象，且在实现引脚后免费。

若您仍存疑，请尝试信号！再次强调：其开发目的是帮助开发人员减少诸如处理像低电平有效vs高电平有效信号这种无用的差异，
并允许其他用户共享您的应用程序，而不会因为他们的LED或继电器的连线方式稍有不同而使应用程序无法运行而沮丧。

构造函数
------------

.. class:: Signal(pin_obj, invert=False)
           Signal(pin_arguments..., \*, invert=False)

   创建一个信号对象。有两种创建方式:

   * 通过包裹现有的引脚对象 — 适用于任何板的通用方法.
   * 通过将所需引脚参数直接传递到信号构造函数，避开创建引脚对象的中间环节。在许多板上可使用此方法，但并非在所有板上可用。

   参数为:

     - ``pin_obj`` 为现有的引脚对象。

     - ``pin_arguments`` 即为可被传递到引脚构造函数的同个参数。

     - ``invert`` - 若为True，则信号将被反转（低电平有效）。

方法
-------

.. method:: Signal.value([x])

   此方法允许设置或获取信号的值，这取决于是否提供了参数 ``x`` 。

   若参数被省略，则此函数获取信号电平，1意为信号有效，0为信号无效。

   若提供了参数，则类函数设置信号电平。 ``x`` 参数可为可转换为布尔值的任何数值。若其转换为 ``True`` ，则信号有效，否则信号无效。

   信号有效与底层引脚上的实际逻辑电平之间的对应关系取决于信号是否反相（低电平有效）。
   对于非反相信号，有效状态对应逻辑1，无效状态对应逻辑0。对于反相/低电平有效信号，有效状态对应逻辑0，无效状态对应逻辑1。

.. method:: Signal.on()

   激活信号。

.. method:: Signal.off()

   关闭信号。

切换、回调和中断
====================================

Pyboard有2个小开关，名为USR和RST。RST开关是一个硬重置开关，若您点击此开关，则将从头开始重启pyboard，也就等同于关闭电源后重启。

USR用于一般用途，通过一个Switch对象实现对其控制。制作Switch对象，请遵循以下指令::

    >>> sw = pyb.Switch()

请记住：若您遇到 ``pyb`` 不存在的错误，
您需要输入 ``import pyb`` 。

使用Switch对象，您可获得其状态::

    >>> sw.value()
    False

若按住开关，则会打印False；
若松开开关，则会打印True。尝试在运行以上指令时按下USR开关。

另外还有一个获取开关状态的简写表示，“调用”开关对象：::

    >>> sw()
    False

开关回调
----------------

开关是一个非常单一的对象，但其有一个高级特性： ``sw.callback()`` 函数。 回调函数设置在按下开关时运行的内容，并使用中断。
建议您在了解中断运行前，先从使用示例开始。尝试在提示符中运行以下指令::

    >>> sw.callback(lambda:print('press!'))

这一指令要求在每次按下开关时打印 ``press!`` 。继续进行并尝试：按下USR开关并查看电脑上的输出。
注意：打印将中断您正在输入的内容，且该打印是异步运行的中断例程的一个示例。

另外一例是::

    >>> sw.callback(lambda:pyb.LED(1).toggle())

这将在每次按下开关时切换红色LED，且可在其他代码运行时一起工作。

将 ``None`` 传递给回调函数以禁用开关回调::

    >>> sw.callback(None)

您可将任何函数（需要0参数）传递给开关回调。上面我们使用Python的 ``lambda`` 特性创建了一个匿名函数。但是我们也可以使用::

    >>> def f():
    ...   pyb.LED(1).toggle()
    ...
    >>> sw.callback(f)

这创建了一个名为 ``f`` 的函数，并将此函数赋值给开关回调。
当您的函数比 ``lambda`` 所允许的更复杂时，您可以以这种方式进行。

注意：您的回调函数不能分配任何内存（例如：他们无法创建一个元组或列表）。
回调函数应相对简单。若您需要制作一个列表，请预先创建并将其存储在全局变量中（或使其成为本地并将其关闭）。
若您需要进行较长且复杂的运算，则使用回调设置一个标记，其他代码会对其应答。

中断的技术细节
-------------------------------

我们来理顺与开关回调相关的细节。当您使用 ``sw.callback()`` 记录一个函数时，开关则在开关连接的引脚上设置一个外部中断触发（下降沿）。
这也就意味着微控制器会监听引脚的任何变化，且以下情况将会出现:

1. 按下开关时，引脚就发生了变化（引脚从低到高），且微控制器会记录这一变化。
2. 微控制器结束执行当前机器指令，停止执行，并保存当前状态（将寄存器推到堆栈上）。这将产生的影响是暂停编码，例如您正在运行的Python脚本。
3. 微控制器开始执行与开关的外部触发相关的特殊中断处理程序。此中断处理程序获取您使用 ``sw.callback()`` 记录的函数并执行。
4. 您的回调函数始终执行，直至完成为止，并将控制返还给开关中断处理程序。
5. 开关中断处理程序返回，微控制器被告知中断已被处理。
6. 微控制器恢复在步骤2中保存的状态。
7. 执行在开始时运行的代码。除暂停外，这一代码不会注意到已被中断。

多个中断同时进行时，以上步骤的进行则会略有复杂。在这种情况下，具有最高优先级的中断首先发生，然后其他按优先级顺序排列。开关中断设置在最低优先级。

扩展阅读
---------------

使用硬件中断的更多信息，请参见
:ref:`writing interrupt handlers <isr_rules>`.

定时器
==========

Pyboard有14个定时器，每个都包括一个独立的以用户定义的频率运行的计数器。
这些计数器可被设置为以特定时间间隔运行函数。14个定时器以1-14命名，
但是3为内部使用预留，5和6用于伺服和ADC/DAC控制。若可能，请避免使用这几个定时器。

创建一个定时器对象::

    >>> tim = pyb.Timer(4)

现在看一下我们刚才创建的::

    >>> tim
    Timer(4)

Pyboard正表示， ``tim`` 属于4号定时器，但其尚未初始化。所以我们将其初始化为以10Hz的频率触发（每秒钟10次）::

    >>> tim.init(freq=10)

现在此定时器已被初始化，我们可以看到关于此定时器的信息::

    >>> tim
    Timer(4, prescaler=624, period=13439, mode=UP, div=1)

T此信息意为此定时器设置为以外围时钟速度除以(624+1)运行，它将从0上升至13439，在这个点上将触发一个中断，
然后再次从0开始。这些数字设置为使定时器以10Hz触发： 定时器的源频率为84MHz（通过运行 ``tim.source_freq()`` 发现），
因此我们可得 84MHz / 625 / 13440 = 10Hz.

定时计数
-------------

我们可以用定时器做什么？最基本的就是获取其计数器的当前数值::

    >>> tim.counter()
    21504

计数器将不断改变，并计算总和。

定时器回调
---------------

我们要做的下一件事是记录一个当触发时定时器执行的回调函数（回调函数介绍见【开关教程】（开关教程））::

    >>> tim.callback(lambda t:pyb.LED(1).toggle())

这一步骤将使红色LED立即开始以5Hz的频率闪烁（1个LED需要2次切换，所以以10Hz频率切换时，闪烁的频率为5Hz）。您可通过重新初始化定时器来更改频率。::

    >>> tim.init(freq=20)

您可通过将值 ``None`` 传递给回调来禁用回调::

    >>> tim.callback(None)

您传递给回调的函数需1个参数，即触发的定时器对象。这使得您可在回调函数内控制定时器。

我们可创建2个定时器并单独运行它们::

    >>> tim4 = pyb.Timer(4, freq=10)
    >>> tim7 = pyb.Timer(7, freq=20)
    >>> tim4.callback(lambda t: pyb.LED(1).toggle())
    >>> tim7.callback(lambda t: pyb.LED(2).toggle())

由于回调属于适当的硬件中断，所以我们可以继续在定时器运行时将pyboard作他用。

制作一个微秒计数器
----------------------------

您可使用定时器来创建一个微秒计数器，计数器可在您需要准确计时时发挥其用。
我们使用定时器2来制作，因为此定时器有一个32位的计数器（定时器5也是如此，但是若您选用定时器5，就无法同时使用伺服驱动）。

我们将定时器2作如下设置::

    >>> micros = pyb.Timer(2, prescaler=83, period=0x3fffffff)

预分频器设置为83，以使定时器以1MHz频率计数。这是因为CPU时钟以168MHZ频率运行，
此数值除以2再除以分频器+1，即得到定时器2的频率为168 MHz/2/(83+1)=1。
周期设置为较大数值，定时器才不至于计数数值较小时就归零。在此种情况下，定时器归零前约有17分钟。

使用此定时器，最好首先将其重置为0::

    >>> micros.counter(0)

然后开始计时::

    >>> start_micros = micros.counter()

    ... do some stuff ...

    >>> end_micros = micros.counter()
